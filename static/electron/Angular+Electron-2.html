<h2 id="-angular-electron-2">使用 Angular 构建 Electron 应用 - 2</h2>
<blockquote>
<p>本文所有代码都可以在 <a href="https://github.com/WittBulter/news-feed">github</a> 找到。你可以通过 commit 历史来查看这些代码是如何一步一步构建的。
如果有任何问题，也可以在 github 的 issue 上提出。</p>
</blockquote>
<p>接前文，现在我们搭建好了一系列的环境，创建了一些初始的代码，是时候开始工作了。
在这篇文章中我们主要负责创建登录界面与主界面，涉及篇幅关系我们不再使用远程服务端来交互，而是创建一些模拟的登录请求，
当然，与服务端的交互方法可以在此系列文章后面几篇找到。OK，这里我们希望前端能够像QQ或微信一样，先展示一个登录界面，
在登录成功后带领我们打开一个长时间停留的主界面，我们先理清需要做那几件事：  </p>
<ol>
<li>在 Angular 中创建路由，包括登录界面与主界面。</li>
<li>创建 browser 相关代码，给登录与跳转提供通信反馈。</li>
<li>在登录成功后我们关闭登录界面跳转至主界面。</li>
</ol>
<h2 id="angular-">Angular创建前端页面</h2>
<blockquote>
<p>由于我们安装了 angular-cli，所以每次创建各类文件时都可以通过cli的方式来解决，这很方便，也降低了 Angular 的学习成本，
如果对此不明白，可以看这里的<a href="https://github.com/angular/angular-cli">文档</a>。  </p>
</blockquote>
<h4 id="1-">1, 创建组件与路由</h4>
<p> 首先在 <code>src/app</code> 的路径下创建2个组件: login 与 main。好吧，你需要输入 <code>ng g component login</code> 来创建这个组件，但在之后我们就不再讨论这些细节，
 我只会告诉该怎么做一件事。</p>
<p> 其次我们在 <code>src/app</code> 的路径下创建一个路由 <code>app.routing.ts</code>，我们希望它可以做好两件事，根据URL进行页面的导航，在没有权限时对相应的导航进行保护。
 具体代码可以参照 Angular 的官方文档，但我猜你们懒得看，代码如下:</p>
<pre><code class="lang-javascript">
<span class="hljs-keyword">import</span> { NgModule } from <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { Routes, RouterModule } from <span class="hljs-string">'@angular/router'</span>

<span class="hljs-keyword">import</span> { LoginComponent } from <span class="hljs-string">'./login/login.component'</span>
<span class="hljs-keyword">import</span> { MainComponent } from <span class="hljs-string">'./main/main.component'</span>

export const <span class="hljs-string">appRoutes:</span> Routes = [
  {<span class="hljs-string">path:</span> <span class="hljs-string">''</span>, <span class="hljs-string">component:</span> LoginComponent},
  {<span class="hljs-string">path:</span> <span class="hljs-string">'login'</span>, <span class="hljs-string">component:</span> LoginComponent},
  {<span class="hljs-string">path:</span> <span class="hljs-string">'main'</span>, <span class="hljs-string">component:</span> MainComponent},
]

<span class="hljs-meta">@NgModule</span>({
<span class="hljs-symbol">  imports:</span> [RouterModule.forRoot(appRoutes)],
<span class="hljs-symbol">  exports:</span> [RouterModule],
})
export <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppRoutingModule</span> {</span>
}
</code></pre>
<p> ok，这很简单，和我们熟悉的 AngularJS 或 react-route 也没有太大区别。但是要让路由运行起来还要做两件事，第一是将路由在 app.module.ts 中注册，
 在 Module 上挂载文件，Angular 在编译时才会找到这些文件，第二是在 app.component.html 中增加路由插座。</p>
<h4 id="2-">2, 创建样式与逻辑</h4>
<p> 现在，我们为前端页面添加一些样式与逻辑，这此的 commit 记录在<a href="https://github.com/WittBulter/news-feed/tree/5374aaa4d678a5eb98fdbfce0dfcae94cd725ead">这里</a>，现在我们需要为登录界面添加逻辑与路由保护。</p>
<p> <img src="assets/electron-demo-2.png" alt="登录页面样式"></p>
<p> 登录可以提交用户名与密码用作验证，这时候可以借助Angular的模板语法来快速的完成它们:  </p>
<pre><code class="lang-html">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"input-box"</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> #<span class="hljs-attr">username</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"input-box"</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> #<span class="hljs-attr">password</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;button (click)=<span class="hljs-string">"login(username.value, password.value)"</span>&gt;登录&lt;<span class="hljs-regexp">/button&gt;</span>
</code></pre>
<p> 我们希望所有严格的逻辑或涉及数据库的问题都放在主进程解决，那么确认登录需要与electron主进程进行交互，以便于主进程来切换窗口。当然，在实际业务中你可以选择把服务器的交互放在Angular中来做，也可以在electron发起一个request。现在我们按下面几步来操作：</p>
<ol>
<li>在 Login 组件文件夹下创建 login.service.ts，别忘了将服务添加到组件的 providers 依赖项中！</li>
<li>在 <code>src/index.html</code> 文件中添加 <code>var electron = require(&#39;electron&#39;)</code>，别忘了 script 标签。</li>
<li>在 <code>src/app</code> 下添加 shared 文件夹，用来存放一些共用的组件与逻辑。在这里创建一个名为 <code>ipc-renderer</code> 的服务，
并将它注册到 <code>app.component.ts</code> 中。具体代码如下：  </li>
</ol>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> electron: <span class="hljs-built_in">any</span>

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> IpcRendererService {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {
  }

  <span class="hljs-keyword">private</span> ipcRenderer = electron.ipcRenderer

  on(message: <span class="hljs-built_in">string</span>, done) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ipcRenderer.on(message, done)
  }

  send(message: <span class="hljs-built_in">string</span>, ...args) {
    <span class="hljs-keyword">this</span>.ipcRenderer.send(message, args)
  }

  api(action: <span class="hljs-built_in">string</span>, ...args) {
    <span class="hljs-keyword">this</span>.ipcRenderer.send(<span class="hljs-string">'api'</span>, action, ...args)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">this</span>.ipcRenderer.once(<span class="hljs-string">`<span class="hljs-subst">${action}</span>reply`</span>, <span class="hljs-function">(<span class="hljs-params">e, reply, status</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (!reply) <span class="hljs-keyword">return</span> reject(status)
        <span class="hljs-keyword">return</span> resolve(reply)
      })
    })
  }

  dialog(action: <span class="hljs-built_in">string</span>, ...args) {
    <span class="hljs-keyword">this</span>.ipcRenderer.send(<span class="hljs-string">'dialog'</span>, action, ...args)
  }

  sendSync(message: <span class="hljs-built_in">string</span>, ...args) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ipcRenderer.sendSync(message, <span class="hljs-built_in">arguments</span>)
  }
}
</code></pre>
<blockquote>
<p>这里我们通过 <code>ipcRenderer</code> 与 electron 交互，ipc-renderer 就是 Angular 中用来通信的公共服务，这个服务模块理论上共享的，
而且我们也只希望它被实例化一次，所以将它注入在 <code>app.component.ts</code> 中。这样每次子组件需要服务时不必在 providers 中标明它，而是直接在
 constructor 中注入即可。这很重要，特别是你想要在一个类中保存一些即时的数据信息，希望只存在一个实例用来共享时很有用。
可以看出来，api 这个方法是我们增加的一个有意思的方法，这里我们可以作出一些参数上的约定，便于监听事件时做出更好的反馈。</p>
</blockquote>
<h4 id="3-">3, 监听与反馈</h4>
<p>这时，api 的第一个参数被约定为 action，用于描述这个 API 事件的用途，每一个 API 事件都会发起一次 <code>apiName+reply</code> 的事件用于回复。
在 Angular 的公共服务中，我们不妨先把它转化为我们熟悉的 Promise，再返回给每一个具体的组件服务，当然你也可以直接把它用作做 fromEvent的Observable，
但在这里，我们希望它看起来像是一个 http 服务，便于大家更好的理解它们工作的方式。
实际上，你可以选择一些成熟 electron 数据通信库或框架来解决这些复杂的问题，但在第一次请不要这样做，这就像上手使用 Rails 一样，
虽然做的很快，但对你并没有多少益处。  </p>
<p> 这里有一些复杂，如果你希望对照当时的代码来学习，可以看这一次的 <a href="https://github.com/WittBulter/news-feed/tree/e756fff44ab931f0fc360b62664a1825bb1de665">commit</a>。</p>
<p> ok，大家也可以想象的到，现在要做的是在 electron 中新建一个事件接收器，处理一些逻辑并且将它们返回，在根文件夹下新建 <code>browser/ipc/index.js</code> 并且填充基础的代码：</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { ipcMain } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'electron'</span>)
<span class="hljs-keyword">const</span> api = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./api'</span>)

ipcMain.on(<span class="hljs-string">'api'</span>, <span class="hljs-function">(<span class="hljs-params">event, actionName, ...args</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> reply = <span class="hljs-function">(<span class="hljs-params">replayObj, status = 'success'</span>) =&gt;</span> {
    event.sender.send(<span class="hljs-string">`<span class="hljs-subst">${actionName}</span>reply`</span>, replayObj, status)
  }
  <span class="hljs-keyword">if</span> (api[actionName]) {
    api[actionName](<span class="hljs-built_in">Object</span>.assign({ reply: reply }, event), ...args)
  }
})
</code></pre>
<p>假设现在有一个 <code>browser/ipc/api</code> 文件作为处理器，以上代码做的事情即是确定一个 Action，并且监听事件，为 event 合并一个名为 <code>reply</code> 的方法，
用于返回数据。根据此，我们再创建这个虚拟的 <code>browser/ipc/api</code> 文件：</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">module</span>.exports = {
  login: <span class="hljs-function"><span class="hljs-params">(e, user)</span> =&gt;</span> {
    <span class="hljs-regexp">//</span> todo something

    e.reply({ msg: <span class="hljs-string">'ok'</span> })
  },
}
</code></pre>
<p>怎么样？现在看起来一切都完成了！每次当我们在 LoginService 中调用 <code>this.ipcRendererService.api</code> 时，相应的数据就会被传达至对应的事件
(看起来它更像一个路由)上，我们在 nodejs 环境中做一些操作，比如储存 session，更新数据库，抓取新闻，向远程服务器发送一条信息等等。</p>
<p>最关键的是我们也能用轻而易举的方式来得到想要的数据，回复数据也足够简单，<code>e.reply({msg: &#39;ok&#39;})</code> 就像是express中的 <code>res.xxx({});</code> 一样，
整个项目也变得层次分明。等到有一天我们需要下载、上传、显示系统原生提示框、读取一个文件等等之类的功能时，只需要将 Action 名替换一下，
在 api 文件夹下新增几段逻辑即可。  </p>
<p>这一小节文章有些琐碎和复杂，登录成功与跳转等等逻辑不妨放在下一节中再讲。大家可以尝试阅读 github 的源码，考虑它有哪些问题是值得优化的。
在后面几节中，我们再来讨论如何优化这些逻辑。</p>
