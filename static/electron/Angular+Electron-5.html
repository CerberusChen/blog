<h2 id="-angular-electron-5">使用 Angular 构建 Electron 应用 - 5</h2>
<p>这次我们开始关注Angular怎样构建前端路由与逻辑，它与你以前熟悉的方式有一些区别，同时这部分内容非常充实，路由发生变化后原有的文件结构也随之变化，
有疑问请参见本次代码变更的 <a href="https://github.com/WittBulter/news-feed/tree/67a566bbee81e7a5b217db29b2a629a0d432493b">Commit</a>。</p>
<p>在进行新的开发之前我们不妨对原有的爬虫代码做一些轻微的更改，在正式显示这些内容时，仅仅有标题与文章详情是远远不够的，
可以加入类似于摘要、描述、阅读量、发表人、发表日期等等字段，具体也根据实际爬取的页面与业务需求更改，
为此我丰富了 <code>browser/task/ifeng.js</code> 中 parseContent 函数的代码：</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// browser/task/ifeng.js</span>
<span class="hljs-comment">// ....</span>
parseContent(html) {
  <span class="hljs-keyword">if</span> (!html) <span class="hljs-keyword">return</span>
  <span class="hljs-keyword">const</span> $ = cheerio.load(html)
  <span class="hljs-keyword">const</span> title = $(<span class="hljs-string">'title'</span>)
    .text()
  <span class="hljs-keyword">const</span> description = $(<span class="hljs-string">'meta[name="description"]'</span>)
    .attr(<span class="hljs-string">'content'</span>)
  <span class="hljs-keyword">const</span> content = $(<span class="hljs-string">'.yc_con_txt'</span>)
    .html()
  <span class="hljs-keyword">const</span> hot = $(<span class="hljs-string">'span.js_joinNum'</span>)
    .text()
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">title</span>: title,
    <span class="hljs-attr">content</span>: content,
    <span class="hljs-attr">description</span>: description,
    <span class="hljs-attr">hot</span>: hot,
    <span class="hljs-attr">createdAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
  }
}
</code></pre>
<h3 id="-angular-">创建 Angular 子模块</h3>
<p>在 Angular 中，模块是用来描述各个组件之间关系的文件，就像是树的枝干，所有小的枝干都汇集至此，在模块中填充，
模块用一些特有的语法糖来描述它们之间的关系与依赖。在应用复杂时，树的枝干往往不止一根，我们不可能将所有的文件全部挂载在根模块中，
这样既不优雅也会导致打包的单个文件过大，影响页面首次加载速度。为此，我们可以在根模块上注册一些子模块，用来描述完全不同且能够得到自治的子模块。  </p>
<blockquote>
<p>「自治」是非常关键的一点，这很像 AngularJS 中的概念。我们知道在 AngularJS 中 Module 也是可以互相依赖的，
每一个模块/指令/服务都应当能够不受任何状态影响完成基础逻辑。想象一下，我们加入指令前需要考虑为指令新建一个模板，
新建几个变量放在模板的某个位置等等，这肯定会使整体耦合性过强。在 Angular 中 pipe 便有『纯』与『非纯』的概念，
非纯的管道在变更时就需要考虑更多的外部环境变化，当然效率也会大大下降。我们希望大部分的函数、代码段、集合都能达到自治的标准，
这也是大家常说的高内聚低耦合。</p>
</blockquote>
<p>Main 组件是用户浏览的主体部分，在界面设计上它至少可以分为两个部分，首先是一侧的菜单与用户信息显示，其次是主要显示区域，
当然你还可以为它增加一些隐藏、悬浮、弹出菜单。这里至少包含三个组件：菜单、列表、详情，我们先用 angular-cli 命令生成它们：</p>
<pre><code class="lang-bash">ng g <span class="hljs-keyword">component</span> main-detail
ng g <span class="hljs-keyword">component</span> main-menu
ng g <span class="hljs-keyword">component</span> main-list
</code></pre>
<p>组件准备就绪，我们在 <code>src/app/main</code> 文件夹下新增模块与路由文件，并把原有的组件改造为路由插座：</p>
<pre><code class="lang-javascript"><span class="hljs-regexp">//</span> src/app/main/main.<span class="hljs-built_in">module</span>.ts 子模块文件
<span class="hljs-keyword">import</span> { CommonModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common'</span>
<span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { FormsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>
<span class="hljs-keyword">import</span> { MainRoutingModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./main.routing'</span>

<span class="hljs-keyword">import</span> { MainComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./main.component'</span>
<span class="hljs-keyword">import</span> { MainListComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./main-list/main-list.component'</span>
<span class="hljs-keyword">import</span> { MainDetailComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./main-detail/main-detail.component'</span>
<span class="hljs-keyword">import</span> { MainMenuComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./main-menu/main-menu.component'</span>

@NgModule({
  declarations: [
    MainComponent,
    MainListComponent,
    MainDetailComponent,
    MainMenuComponent,
  ],
  imports: [
    CommonModule,
    FormsModule,
    MainRoutingModule,
  ],
  exports: [MainComponent],
  providers: [
    SanitizePipe,
  ],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainModule</span> {</span>
}
</code></pre>
<pre><code class="lang-javascript"><span class="hljs-comment">// src/app/main/mian.routing/ts 路由文件</span>
<span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { RouterModule, Routes } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>

<span class="hljs-keyword">import</span> { MainComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./main.component'</span>
<span class="hljs-keyword">import</span> { MainListComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./main-list/main-list.component'</span>
<span class="hljs-keyword">import</span> { MainDetailComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./main-detail/main-detail.component'</span>


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mainRoutes: Routes = [{
  <span class="hljs-attr">path</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">component</span>: MainComponent,
  <span class="hljs-attr">children</span>: [{
    <span class="hljs-attr">path</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">redirectTo</span>: <span class="hljs-string">'list'</span>, <span class="hljs-attr">pathMatch</span>: <span class="hljs-string">'full'</span>,
  }, {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'list'</span>, <span class="hljs-attr">component</span>: MainListComponent,
  }, {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'list/:id'</span>, <span class="hljs-attr">component</span>: MainDetailComponent,
  }],
}]

@NgModule({
  <span class="hljs-attr">imports</span>: [RouterModule.forChild(mainRoutes)],
  <span class="hljs-attr">exports</span>: [RouterModule],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainRoutingModule</span> </span>{
}
</code></pre>
<p>子模块也需要被根模块检测到才能在编译时被纳入，这里考虑到 <code>main.module</code> 是一个子路由产生的懒模块，我们可以考虑在路由转向它时才开始加载。
这时 app.routing 需要改写一条路由规则：<code>{path: &#39;main&#39;, loadChildren: &#39;./main/main.module#MainModule&#39;, data: {preload: true}}</code>。</p>
<p>从现在开始，每当我们访问 /mian 路由时 Angular 会自动为我们加载新的模块，在访问 <code>/mian/*</code> 时，
<code>main.routing.ts</code> 文件会开始检测路由地址并切换到相应的页面组件上。后面所有的业务都将专注于 main 路由中，为了项目的可读性，
每个子路由工作的子页面组件，都应当写在 main 文件夹下。</p>
<h3 id="-">编写组件与公共服务</h3>
<p>我为 main 下的组件写了一些样式，具体可以参考 <a href="https://github.com/WittBulter/news-feed/tree/67a566bbee81e7a5b217db29b2a629a0d432493b">Commit</a>，它看起来有些简陋但并没有关系，在编写应用时不能把注意力过于集中在某一点上，一开始写出非常严谨、不可变的样式会使随后的逻辑重构畏首畏尾，整体式的推进、优化可以大大提升项目进度。等到应用能够运行时我们再回过头来考虑这些问题。</p>
<p>与登录相似，在每个组件下创建一个 service，需要记住的是，当前组件下的 service 仅仅只供给当前组件使用，它被写在组件的 providers 依赖列表里，
如果你真的需要一个共享或状态存储(单次实例)的组件，可以考虑 shared 文件夹。举个例子来说，现在我们的数据库中文章详情是 html 富文本格式，
这些源数据是不能够被直接解析在 dom 结构中的，还需要做一些安全化处理，我们以这个功能为例，创建一个公共的 pipe 解析器。
在 <code>shared/pipe/sanitize</code> 下创建一个 pipe：</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> { Pipe, PipeTransform } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { DomSanitizer, SafeHtml } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>

<span class="hljs-meta">@Pipe</span>({
  name: <span class="hljs-string">'sanitize'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SanitizePipe <span class="hljs-keyword">implements</span> PipeTransform {

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> domSanitizer: DomSanitizer</span>) {
  }

  transform(value: <span class="hljs-built_in">any</span>, args?: <span class="hljs-built_in">any</span>): SafeHtml {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.domSanitizer.bypassSecurityTrustHtml(value)
  }

}
</code></pre>
<p>前面在创建公共 service 时我们使用了一种投机取巧的方式，即是将公共 service 注入在 app.component 的 providers 依赖列表中，
因为根组件最多只会创建一次，借此机制拿到一个只会被实例化一次的服务。但这不是工程化的做法(显而易见)，结合上文所提到 Angular 的 Module机制，
我们可以为 shared 建立一个独立的 Module，用来解决这些问题：</p>
<pre><code class="lang-javascript"><span class="hljs-regexp">//</span> src/app/shared/shared.<span class="hljs-built_in">module</span>.ts

<span class="hljs-keyword">import</span> { ModuleWithProviders, NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { CommonModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common'</span>
<span class="hljs-keyword">import</span> { FormsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>

<span class="hljs-keyword">import</span> { IpcRendererService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./service/ipcRenderer'</span>
<span class="hljs-keyword">import</span> { SanitizePipe } <span class="hljs-keyword">from</span> <span class="hljs-string">'./pipe/sanitize'</span>

@NgModule({
  imports: [
    CommonModule,
    FormsModule,
  ],
  declarations: [
    SanitizePipe,
  ],
  exports: [
    SanitizePipe,
  ],
  providers: [],
})

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedModule</span> {</span>
  static forRoot(): ModuleWithProviders {
    <span class="hljs-keyword">return</span> {
      ngModule: SharedModule,
      providers: [IpcRendererService],
    }
  }
}
</code></pre>
<p>forRoot 静态方法是 Angular 的一个公约，具体可以参见官方文档，大家只需要知道的是在 app.module 的 imports 依赖中调用 <code>SharedModule.forRoot(),</code> 
而其他地方仅仅依赖 <code>SharedModule</code> 即可。看它们不同的使用方法很多人应该已经猜出 Module是怎样工作的了，先不管这些，
让我们回到 mian.module 里注入依赖项试试效果。</p>
<h3 id="-">新的通信接口</h3>
<p>在此之前，我们约定了接口语法为 <code>ipcRendererService.api(&#39;接口名&#39;, &#39;参数&#39;)</code>，新增的组件里也参考此方式发起请求即可，
这里我们可能至少需要两个接口：<code>this.ipcRendererService.api(&#39;list&#39;, page)</code>，<code>this.ipcRendererService.api(&#39;detail&#39;, id)</code>。
想象一下，在列表组件初始化时调用 list 接口传入一个页码获得一些列表数据，紧接着使用 Angular 的路由方法 <code>this.router.navigate([&#39;/main/list&#39;, id])</code> 
把列表中某一项的 id 传至详情页面，详情页面在初始化时从 url 上取得页面 id，再次通过 detail 接口获取自己需要的文章详情数据。一次正常的浏览就完成了。
在给 Electron 中的 api 增加方法时先等等，上一篇文章我们聊到 Async 函数，现在我们可以使用 async 函数来时路由更简单易懂一些：</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// browser/ipc/index.js</span>

<span class="hljs-keyword">const</span> { ipcMain } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'electron'</span>)
<span class="hljs-keyword">const</span> api = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./api'</span>)

ipcMain.on(<span class="hljs-string">'api'</span>, <span class="hljs-function">(<span class="hljs-params">event, actionName, ...args</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> reply = <span class="hljs-function">(<span class="hljs-params">replayObj, status = 'success'</span>) =&gt;</span> {
    event.sender.send(<span class="hljs-string">`<span class="hljs-subst">${actionName}</span>reply`</span>, replayObj, status)
  }
  <span class="hljs-keyword">if</span> (api[actionName]) {
    api[actionName](event, ...args)
      .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> reply(res))
      .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> reply({ message: <span class="hljs-string">'应用出现了错误'</span> }))
  }
})
</code></pre>
<p>现在我们假设路由文件已经是 async 函数构成的，先将回复方法(reply 函数)放在外部，取消之前的对象合并。虽然前面使用对象合并避免对侵入原生对象，
但也并不是那么优雅，现在只考虑返回值无疑是最酷的做法！</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// browser/ipc/api/index.js</span>
<span class="hljs-keyword">const</span> screen = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../screen'</span>)
<span class="hljs-keyword">const</span> articleService = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../service/article'</span>)

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">login</span>: <span class="hljs-keyword">async</span>(e, user) =&gt; {
    <span class="hljs-comment">// todo something</span>
    screen.setSize(<span class="hljs-number">1000</span>, <span class="hljs-number">720</span>)
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">msg</span>: <span class="hljs-string">'ok'</span> }
  },
  <span class="hljs-attr">list</span>: <span class="hljs-keyword">async</span>(e, page) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> articles = <span class="hljs-keyword">await</span> articleService.findArticlesForPage(page)
      <span class="hljs-comment">// todo filter articles</span>
      <span class="hljs-keyword">return</span> articles
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err)
    }
  },
  <span class="hljs-attr">detail</span>: <span class="hljs-keyword">async</span>(e, id) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> article = <span class="hljs-keyword">await</span> articleService.findArticleForID(id)
      <span class="hljs-keyword">return</span> article
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err)
    }
  },
}
</code></pre>
<p><code>articleService</code> 是原生数据库查询的封装，相比于每次写 find/update 方法与大量参数，我更建议大家把这些垃圾代码统一封装成更富有语义性的函数，
无论过去多久，你再次读到这段代码时总能很清楚的知道自己做了什么，这很关键。
另外，我给大家展示的是代码框架如何搭建，单个 await 带来的便利性没有想象的大，但你在实际业务中会涉及多次查询、更新、筛选、遍历操作，
async 语法糖会给你带来极高的可读性！</p>
<p>现在 news-feed 已经能够快速显示出数据库里的列表：
<img src="assets/electron-demo-4.png" alt="列表demo"></p>
<p>点击任何一项进入详情，文章内容都被 <code>sanitize.pipe</code> 过滤解析在 dom 里：
<img src="assets/electron-demo-5.png" alt="详情demo"></p>
<h3 id="-">最后</h3>
<p>当然，news-feed 还存在很多问题，甚至还不能称之为一个应用，比如不能注销登录、浏览文章时无法返回列表、无法下载文章内容/图片、没有跳转到原文等等。
这些细节是真正值得注意的重点，后面几节我们都会一起讨论怎样添加这些逻辑并优化现有的代码。</p>
